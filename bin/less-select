#!/usr/bin/perl
use warnings;
use strict;
use integer;
use Pod::Usage;
use Getopt::Long;
use File::Temp qw/tempdir/;

sub Version {
	print "less-select v1.4 by Martin Väth\n"
	 .    "martin\@mvath.de\n";
	exit 0
}

=head1 NAME

less-select - select interactively files from a list to process them

=head1 SYNOPSIS

B<less-select> [options] [B<-->] I<command> I<args>

or

B<less-select> [options] [B<-->] I<command> I<args> B<@> I<selection list>

One of the I<args> should be (or at least start with) the magic symbol B<@>.
If one of the I<args> starts with B<->, then the B<--> is mandatory.

Type B<less-select --man> for an extended help.

=head1 DESCRIPTION

In its simplest form, one of the arguments in I<args> is the magic symbol B<@>.
Then a patched version of the B<less> program is used to display a list of
all files in the current directory.
Due to this patch you are not only able to B<see> this list of files but even
to B<select> some of these files (for a description how to select, see below).

When you are done (i.e. when you quit B<less>) then I<command> I<args>
is executed where the special argument B<@> within I<args> is replaced
by many arguments, namely by the filenames that you have selected
(in the order you selected them)

Alternatively (if you use the B<-s> or B<-S> option) then I<command> I<args>
is executed consecutively for each filename that you have selected where
B<@> is replaced by that filename.

If you do not want to allow selection of all files of the current directory
but of all files which match a certain filemask, just replace the special
argument B<@> (within I<args>) by the argument B<@>I<Filemask> (then you might
have to quote this argument for the shell so that this argument is actually
passed `as is').

Sometimes it is reasonable to select not from a list of existing files but
instead from an arbitrary list of data. For this purpose, there is a second
form of call of B<less-select> where you append B<@> I<selection list>:
Instead of the files in the current directory, the data
in I<selection list> is displayed for selection.

The keys that can be used for selection are determined by a lesskey file
(created by the B<lesskey> tool). The first existing file in the following
list is used:

=over 8

=item File(s) given by the B<--key> option (in reverse order)

=item Content of environment-variable B<LESSSELECTKEY>

=item F<$HOME/.less-select-key.bin>

=item F</usr/local/etc/less-select.key>

=item F</usr/local/etc/less-select-key.bin>

=item F</usr/local/etc/less/select-key.bin>

=item F</etc/less-select.key>

=item F</etc/less-select-key.bin>

=item F</etc/less/select-key.bin>

=back

The default file (distributed with this program) contains the following keys:

=over 8

=item B<space>

"select/unselect" the file on top of the screen

=item B<return/enter>

"quit and execute" (if nothing else was selected, the file on top of the
screen is selected).

=item B<*>

Toggle all files (i.e. select all unselected files and vice versa)

=item B<#>

Unselect all files

=back

=head1 OPTIONS AND ARGUMENTS

=over 8

=item B<--help> or B<-h>

Display a brief help.

=item B<--man> or B<-?>

Display an extended help
(depending on your perl installation usually as a manpage).

=item B<--single> or B<-s> (switch)

Execute I<command> consecutively for each selected file.

=item B<--Single> or B<-S> (switch)

Execute I<command> consecutively for each selected file, but stop processing
if I<command> returns with a nonzero exit code.

=item B<--visible> or <-v> (switch)

List only non-hidden files.

=item B<--all> or <-a> (switch)

List also the files F<.> and F<..>

=item B<--brief> or <-b> (switch)

Show only the filenames in the listing, not the size and date of the files.

=item B<--long> or <-l> (switch)

Show more information on the files in the listing.

=item B<--emptyrun> or <-e> (switch)

Execute I<command> even if no file is selected.

=item B<--path=>I<path> or B<-p> I<path> (switch)

Do not display the files of the current directory but of the directory I<path>.
Moreover, when executing I<command>, prepend I<path> in front of each
selected filename.

=item B<--sort=>[n|t|s|x|u] or B<-t> [n|t|s|x|u]

Sort listing of files by name (n), time (t), size (s), extension (x)
or unsorted (u). The default is x.

=item B<--reverse> or B<-r> (switch)

Reverse sorting of listing

=item B<--critical=>I<char> or B<-c> I<char>

Let the "critical" argument start with I<char> instead of B<@>.

=item B<--number=>I<n> or B<-n> I<n> (switch)

Magically insert B<@> as the I<n>-th word in the list "I<command> I<args>".
(I<0> means the first word in this list).

=item B<--key=>I<file> or B<-k>I<file>

Use I<file> as F<.key>-file for less.

=item B<--unquoted> or B<-u> (switch)

Pass the filenames unquoted to I<command>.

=item B<--numberpostpone> or B<-N> (switch)

This is a very special options meant to simplify writing aliases.
Essentially, this behaves like the option B<--number>, but the
argument is not read immediately.
Instead, the first non-option argument is interpreted as the argument.

=item B<--pathpostpone> or B<-P> (switch)

This is the analogon to B<--numberpostpone> for the B<--path> option.
If this option is combined with --numberpostpone, the first two non-option
arguments are used (the order of interpretation depends on the order
of the options).

=item B<--version> or B<-V>

print version number

=back

The options marked with (switch) act also as switches, i.e. their negation
(which is always the default) can be re-obtained be proceeding 'no' to
the option. For example, B<--nosingle> cancels the effect of a previous
option B<--single> or B<-s>.

=head1 EXAMPLES OF USAGE

=over 8

=item B<less-select -s -- tar xf '*.tar'>

Display a list of all F<*.tar> files in the current directory and untar
each of the selected files.

=item B<less-select -p ~/src/ cp '@*.c' .>

Display a list of all F<*.c> files of F<~/src> and copy the selected files into
the current directory.

=item B<less-select cp @ ~/bin @ */*>

Display a list of all files residing within one subdirectory of the current
directory and copy the selected files into F<~/bin>.

=item B<less-select cat @ 'E<gt>mergefile'>

Concatenates all selected files into F<mergefile>. Note that the redirection
is quoted, because we do not want to redirect the output of B<less-select>,
but the output of the command B<cat>.

=item B<less-select -n 3 -- cp -r -i ~/bin>

Display a list of all files and copy the selected ones (using the B<cp>
options <-r> and <-i>) into F<~/bin>. The B<--number> option is meant to
be used together with some shell alias or function. For example, if you
have the aliases

=over 4

=item B<alias sel='less-select -n 1 --'>

=item B<alias sel2='less-select -n 2 --'>

=item B<alias sel3='less-select -n 3 --'>

=back

then you can use (depending on the B<cp> options you want):

=over 4

=item B<sel cp ~/bin>

=item B<sel2 cp -r ~/bin>

=item B<sel3 cp -r -i ~/bin>

=back

=over 4

=item B<selx 4 cp -r -i -l ~/bin>

=back

This extends the above commands provided that you have defined the alias

=over 4

=item B<alias selx='less-select -N --'>

=back

=item B<from /usr/bin cp .>

=item B<from2 /usr/bin cp -r .>

=item B<fromx 3 /usr/bin cp -r -i .>

This allows to select files from F</usr/bin> and copies the selected files
(with the corresponding B<cp> options) into the current directory.
Here, it is assumed that you have defined the following aliases:

=over 4

=item B<alias from='less-select -P --'>

=item B<alias from2='less-select -Pn2 --'>

=item B<alias fromx='less-select -NP --'>

=back

=back

=head1 AUTHOR

Martin VE<auml>th E<lt>martin@mvath.deE<gt>

=cut

sub Fatal {
	print(STDERR 'fatal: ', $_[0], "\n");
	exit 1
}

# Default for the options

my @keyfile = (
	'/etc/less/select-key.bin',
	'/etc/less-select-key.bin',
	'/etc/less-select.key',
	'/usr/local/etc/less/select-key.bin',
	'/usr/local/etc/less-select-key.bin',
	'/usr/local/etc/less-select.key'
);

if(exists($ENV{'HOME'}) && defined($ENV{'HOME'}) && ($ENV{'HOME'} ne '')) {
	push(@keyfile, $ENV{'HOME'} . '/.less-select-key.bin')
}
if(exists($ENV{'LESSSELECTKEY'})) {
	push(@keyfile, $ENV{'LESSSELECTKEY'})
}

my $short = 'm';
my $hidden = 'A';
my $critical = '@';
my $sort = 'extension';
my $single = '';
my $errorbreak = '';
my $numberarg = '';
my $critnum = '';
my $emptyrun = '';
my $withpath = '';
my $mypath = '';
my $reverse = '';
my $quote = "\'";

# Parse Options:

my @postpone = ();

sub Postpone {
	my($a) = @_;
	foreach my $i (@postpone) {
		return if($i eq $a)
	}
	push(@postpone, $a)
}

sub Unpostpone {
	my($a) = @_;
	foreach (@postpone) {
		if($_ eq $a) {
			$_ = '';
			last
		}
	}
}

$Getopt::Long::bundling = 1;
GetOptions(
	'help|h', sub { pod2usage(1) },
	'man|?', sub { pod2usage(-verbose => 2) },
	'version|V', \&Version,
	'single|s', sub { $single=1; $errorbreak = '' },
	'nosingle|nos', sub { $single = '' },
	'Single|S', sub { $single = $errorbreak = 1 },
	'noSingle|noS', sub { $single = $errorbreak = '' },
	'brief|b', sub { $short = 's' },
	'nolong|nobrief|nol|nob', sub { $short = 'm' },
	'long|l', sub { $short = 'L' },
	'visible|v', sub { $hidden = '' },
	'all|a', sub { $hidden = 'a' },
	'novisible|noall|nov|noa', sub { $hidden = 'A' },
	'emptyrun|e', sub { $emptyrun = 1 },
	'noemptyrun|noe', sub { $emptyrun = '' },
	'unquoted|u', sub { $quote = '' },
	'nounquoted|nou', sub { $quote = "\'" },
	'path|p=s', sub { (undef, $mypath) = @_; $withpath = 1 },
	'nopath|nop', sub { $withpath = '' },
	'pathpostpone|P', sub { &Postpone('p') },
	'nopathpostpone|noP', sub { &Unpostpone('p') },
	'sort|t:s', sub { (undef, $sort) = @_;
			if   ($sort eq 'n'){ $sort = '' }
			elsif(($sort eq 'x') || ($sort eq '')){ $sort = 'extension'}
			elsif($sort eq 't'){ $sort = 'time'}
			elsif($sort eq 's'){ $sort = 'size'}
			elsif($sort eq 'u'){ $sort = 'none'}
			else{ pod2usage("illegal sort option $sort") }
		},
	'reverse|r', sub { $reverse = 1 },
	'noreverse|nor', sub { $reverse = '' },
	'critical|c:s', sub { (undef, $critical) = @_ },
	'number|n:i', sub { (undef, $critnum) = @_; $numberarg = 1 },
	'nonumber|non', sub { $numberarg = '' },
	'numberpostpone|N', sub { &Postpone('n') },
	'nonumberpostpone|noN', sub { &Unpostpone('n') },
	'key|k:s', sub { push(@keyfile, $_[1]) }
) or pod2usage(2);

foreach my $i (@postpone) {
	unless(scalar(@ARGV)) {
		pod2usage('not enough arguments given')
	}
	if($i eq 'n') {
		$numberarg = 1;
		$critnum = shift(@ARGV);
		$critnum =~ s/\D//g
	}
	elsif($i eq 'p') {
		$withpath = 1;
		$mypath = shift(@ARGV)
	}
}

my @lesskeyopt = ();
foreach my $i (reverse(@keyfile)) {
	if(defined($i) && ($i ne '') && (-r $i)) {
		push(@lesskeyopt, '-k', $i);
		last
	}
}

if($numberarg) {
	my $max = scalar(@ARGV);
	if($critnum > $max) {
		$critnum = $max;
	}
	$critnum = 0 if($critnum < 0);
	@ARGV[$critnum .. $max] = ($critical, @ARGV[$critnum .. $#ARGV]);
} else {
	for($critnum = 0; $critnum < scalar(@ARGV); ++$critnum) {
		last if(substr($ARGV[$critnum], 0, length($critical)) eq $critical)
	}
	if($critnum >= scalar (@ARGV)) {
		pod2usage("no argument starts with \"$critical\".")
	}
}

my @llist = ();
my @ls = ();
my $usualls = 1;
my $lsstring = $ARGV[$critnum];
$lsstring = substr($lsstring, length($critical))
	if(substr($lsstring, 0, length($critical)) eq $critical);
if($lsstring eq '') {
	for(my $fl = $critnum + 1; $fl < scalar(@ARGV); ++$fl) {
		next unless(substr($ARGV[$fl], 0, length($critical)) eq $critical);
		# the critical parameter is empty and a second critical parameter occurs:
		$usualls = '';
		$#llist = $#ls = $#ARGV - $fl - 1;
		my($i, $j);
		for($i = $#ARGV, $j = $#llist; $i > $fl; --$i, --$j) {
			$llist[$j] = $ls[$j] = $ARGV[$i] . "\n"
		}
		$#ARGV = $fl - 1;
		last
	}
}

sub Shq {
	my ($a) = (@_);
	$a =~ s/\'/\'\\\'\'/go;
	$a = "'$a'";
	$a =~ s/(^|[^\\])\'([\da-zA-Z\_\-\,\.\:\/]*)\'/$1$2/g;
	return $a;
}

sub CleanArray {
	my ($a) = @_;
	while($a->[scalar(@$a) - 1] eq "\033\133\155") {
		pop(@$a)
	}
}

my $prepend = '';
my $firstline = 0;
my $skipfirst = 0;
if($usualls) {
	# In the nonexceptional case, we call ls:

	# Call ls two times: First, to generate the list of filenames,
	# second to generate the output in the form desired by the user.
	# Let's hope that the directory is not modified in the meanwhile.

	my $shortls = '';
	my $dirls = '';
	if($short eq 's') {
		$shortls = '';
		$firstline = 0;
		$skipfirst = 0
	} elsif($short eq 'm') {
		$shortls = 'o';
		$firstline = 1;
		$skipfirst = 3
	} else {
		$shortls = 'o';
		$firstline = 1;
		$skipfirst = 0
	}
	if($lsstring ne '') {
		$dirls = 'd';
		$firstline = 0
	}

	my $lsopt = '';
	$lsopt = "--sort=$sort " unless ($sort eq '');
	$lsopt .= "-1$dirls$hidden$reverse";
	my $lscommand = 'ls --color ' . $lsopt . "b$shortls " . $lsstring;
	if($withpath) {
		$lscommand = 'cd -- ' . &Shq($mypath) .
			'  >/dev/null 2>&1 && ' . $lscommand;
		if($lsstring ne '') {
			$lsstring = "$mypath/$lsstring"
		} else {
			$prepend = $mypath . '/';
			$lsstring = $mypath
		}
	}
	my $lcommand = 'ls --color=no ' . $lsopt . ' ' . $lsstring;
	#$ENV{'LANG'} = $ENV{'LANGUAGE'} = $ENV{'LC_MESSAGES'} = 'C';
	#delete $ENV{'LC_ALL'};
	@llist = `$lcommand`;
	@ls = `$lscommand`;
	CleanArray(\@llist);
	CleanArray(\@ls);

	# A small test: At least the number of files should be compatible.
	&Fatal('two subsequent ls-commands produced incompatible output')
		unless(scalar(@ls) - $firstline == scalar(@llist))
}

sub CommandPrintable {
	my @command = ();
	for(my $i = 0; $i < scalar(@ARGV); ++$i) {
		my $myarg = $ARGV[$i];
		if($i == $critnum) {
			$myarg = ($withpath ? ($mypath . '/') : '') . $critical
		}
		$myarg =~ s/[\:\$]/\?/sg;
		$myarg =~ s/([\%\?\.\\])/\\$1/sg;
		push(@command, $myarg)
	}
	return join(' ', @command)
}

sub SaveLs {
	my ($filename) = @_;
	open(my $fh, '>', $filename) or &Fatal("cannot write to $filename");
	my $maxlinelen = 72;
	my $keepatend = 10;
	for(my $i = $firstline; $i < scalar(@ls); ++$i) {
		my $lstemp = $ls[$i];
		for (my $j = 0; $j < $skipfirst; ++$j) {
			$lstemp =~ s/^\s*[^\s]*//
		}
		# Cut the filename, if the line becomes too long:
		# There's a bug in the less-programm for lines longer than a screenline.
		# Better to cut the filenames than to risk that mistakenly the wrong
		# files are selected.
		# $maxlinelen gives the maximal length (including "\n") which is allowed
		# without problems. Usually, this is CHARS_PER_SCREENLINE - TABSIZE.
		# $keepatend is the number of the LAST characters of the line (including
		# "\n") which should not be deleted (i.e. we cut in fact a middle-part of
		# the line. For clarity, we insert dots on the `cut place').
		# Observe that due to the colorization-escape sequences the output may
		# look different than what you expect!
		my $leng = length($lstemp);
		if($leng > $maxlinelen) {
			substr($lstemp, $maxlinelen - $keepatend - 2, -$keepatend) = '..'
		}
		print($fh $lstemp)
	}
	close($fh)
}

# If there is at least one file, we call the less-programm to select:

my @resn = ();
if($firstline < scalar(@ls)) {
	my $prompt = &CommandPrintable . '  (#%lt) ?e:%PB\%';
	my $tempdir = tempdir(CLEANUP => 1);
	my $toless = $tempdir . '/_';
	my $fromless = $tempdir . '/0';
	&SaveLs($toless);
	delete($ENV{'LESS'});
	delete($ENV{'LESSOPEN'});
	system('less', '-frsiucX',
		@lesskeyopt,
		'-Ps' . $prompt,
		'-@', $fromless,
		$toless);
	unlink($toless);

	# If user exited with 'q' or ESC/ESC, no output file has been created.
	# In this case, we just quit
	exit(0) unless(-e $fromless);

	open(my $fh, '<', $fromless) or &Fatal('cannot read output from less');
	@resn = <$fh>;
	close($fh);
	unlink($fromless)
}

undef(@ls);
foreach my $i (@llist) {
	chomp($i)
}

# Now the list of filenames is in @llist, and the selected line numbers in @resn

unless(scalar(@resn)) {
	exit(0) unless($emptyrun);
	$single = ''
}

my @thecmd = @ARGV[0 .. $critnum - 1];
my @theend = @ARGV[$critnum + 1 .. $#ARGV];

unless($single) {
	for(my $i = 0; $i < scalar(@resn); ++$i) {
		push(@thecmd, $prepend . $llist[$resn[$i] - 1])
	}
	exec(@thecmd, @theend)
}

my $exitcode = 0;
for(my $i = 0; $i < scalar(@resn); ++$i) {
	my $retvalue = system(@thecmd, $prepend . $llist[$resn[$i] - 1], @theend);
	if($retvalue) {
		$exitcode = $retvalue;
		exit($retvalue) if($errorbreak)
	}
}

exit($exitcode);
